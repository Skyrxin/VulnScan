"""
Vulnerability Scanner Module

Comprehensive vulnerability testing for common web application security issues.
Implements smart heuristics to minimize false positives.
"""

import requests
import requests.adapters
import re
import time
import random
import base64
from urllib.parse import urljoin, urlparse, parse_qs, urlencode, urlunparse
from bs4 import BeautifulSoup
from concurrent.futures import ThreadPoolExecutor, as_completed
from colorama import Fore, Style
from .payloads import SQLPayloads, XSSPayloads, CSRFPayloads, IDORPayloads, FileDisclosurePayloads

class VulnerabilityScanner:
    def __init__(self, threads=20, timeout=8, verbose=False, fast_mode=False):
        self.threads = threads
        self.timeout = timeout
        self.verbose = verbose
        self.fast_mode = fast_mode
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        
        # Connection pooling for better performance
        adapter = requests.adapters.HTTPAdapter(
            pool_connections=threads,
            pool_maxsize=threads,
            max_retries=1
        )
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)
        
        # Initialize payload modules
        self.sql_payloads = SQLPayloads()
        self.xss_payloads = XSSPayloads()
        self.csrf_payloads = CSRFPayloads()
        self.idor_payloads = IDORPayloads()
        self.file_payloads = FileDisclosurePayloads()

    def log_verbose(self, message):
        """Log verbose messages if verbose mode is enabled"""
        if self.verbose:
            print(f"{Fore.BLUE}[VERBOSE]{Style.RESET_ALL} {message}")

    def scan_vulnerabilities(self, endpoints, selected_scans=None):
        """Scan endpoints for vulnerabilities with selective testing"""
        if selected_scans is None:
            selected_scans = ['sqli', 'xss', 'csrf', 'idor', 'debug', 'files', 'auth', 'tls', 'access']
        
        results = {
            'sql_injection': [],
            'xss': [],
            'csrf': [],
            'idor': [],
            'file_disclosure': [],
            'debug_endpoints': [],
            'weak_authentication': [],
            'broken_access_control': [],
            'session_management': [],
            'tls_issues': []
        }
        
        self.log_verbose(f"Starting vulnerability scan with tests: {', '.join(selected_scans)}")
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Starting vulnerability assessment...")
        
        # Filter endpoints for testing
        testable_endpoints = [ep for ep in endpoints if ep.get('status_code') == 200]
        self.log_verbose(f"Found {len(testable_endpoints)} testable endpoints (200 OK status)")
        
        if not testable_endpoints:
            print(f"{Fore.YELLOW}[WARNING]{Style.RESET_ALL} No testable endpoints found (200 OK status)")
            return results
        
        # Run selected vulnerability tests
        if 'sqli' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for SQL Injection vulnerabilities...")
            sql_vulns = self.test_sql_injection(testable_endpoints)
            results['sql_injection'].extend(sql_vulns)
            self.log_verbose(f"SQL Injection test completed: {len(sql_vulns)} vulnerabilities found")
        
        if 'xss' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for Cross-Site Scripting vulnerabilities...")
            xss_vulns = self.test_xss(testable_endpoints)
            results['xss'].extend(xss_vulns)
            self.log_verbose(f"XSS test completed: {len(xss_vulns)} vulnerabilities found")
        
        if 'csrf' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for CSRF vulnerabilities...")
            csrf_vulns = self.test_csrf(testable_endpoints)
            results['csrf'].extend(csrf_vulns)
            self.log_verbose(f"CSRF test completed: {len(csrf_vulns)} vulnerabilities found")
        
        if 'idor' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for IDOR vulnerabilities...")
            idor_vulns = self.test_idor(testable_endpoints)
            results['idor'].extend(idor_vulns)
            self.log_verbose(f"IDOR test completed: {len(idor_vulns)} vulnerabilities found")
        
        if 'files' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for file disclosure vulnerabilities...")
            file_vulns = self.test_file_disclosure(testable_endpoints)
            results['file_disclosure'].extend(file_vulns)
            self.log_verbose(f"File disclosure test completed: {len(file_vulns)} vulnerabilities found")
        
        if 'debug' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Checking for exposed debug endpoints...")
            base_url = testable_endpoints[0]['url'] if testable_endpoints else None
            if base_url:
                debug_vulns = self.test_debug_endpoints(base_url)
                results['debug_endpoints'].extend(debug_vulns)
                self.log_verbose(f"Debug endpoints test completed: {len(debug_vulns)} vulnerabilities found")
        
        if 'auth' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing authentication mechanisms...")
            auth_vulns = self.test_authentication(testable_endpoints)
            results['weak_authentication'].extend(auth_vulns)
            self.log_verbose(f"Authentication test completed: {len(auth_vulns)} vulnerabilities found")
        
        if 'access' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing access control...")
            access_vulns = self.test_access_control(testable_endpoints)
            results['broken_access_control'].extend(access_vulns)
            self.log_verbose(f"Access control test completed: {len(access_vulns)} vulnerabilities found")
        
        if 'tls' in selected_scans:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing TLS/SSL configuration...")
            base_url = testable_endpoints[0]['url'] if testable_endpoints else None
            if base_url:
                tls_vulns = self.test_tls_configuration(base_url)
                results['tls_issues'].extend(tls_vulns)
                self.log_verbose(f"TLS test completed: {len(tls_vulns)} vulnerabilities found")
        
        total_vulns = sum(len(vulns) for vulns in results.values())
        self.log_verbose(f"Vulnerability scan completed. Total vulnerabilities found: {total_vulns}")
        
        return results

    def scan_all(self, endpoints, base_url=None):
        """Scan all endpoints for vulnerabilities"""
        results = {
            'sql_injection': [],
            'xss': [],
            'csrf': [],
            'idor': [],
            'file_disclosure': [],
            'debug_endpoints': [],
            'weak_authentication': [],
            'broken_access_control': [],
            'session_management': [],
            'tls_issues': []
        }
        
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Starting comprehensive vulnerability scan...")
        
        # Filter endpoints for testing
        testable_endpoints = [ep for ep in endpoints if ep.get('status_code') == 200]
        
        # SQL Injection Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for SQL Injection vulnerabilities...")
        sql_vulns = self.test_sql_injection(testable_endpoints)
        results['sql_injection'].extend(sql_vulns)
        
        # XSS Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for Cross-Site Scripting vulnerabilities...")
        xss_vulns = self.test_xss(testable_endpoints)
        results['xss'].extend(xss_vulns)
        
        # CSRF Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for CSRF vulnerabilities...")
        csrf_vulns = self.test_csrf(testable_endpoints)
        results['csrf'].extend(csrf_vulns)
        
        # IDOR Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for IDOR vulnerabilities...")
        idor_vulns = self.test_idor(testable_endpoints)
        results['idor'].extend(idor_vulns)
        
        # File Disclosure Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing for file disclosure vulnerabilities...")
        file_vulns = self.test_file_disclosure(testable_endpoints)
        results['file_disclosure'].extend(file_vulns)
        
        # Debug Endpoints
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Checking for exposed debug endpoints...")
        debug_vulns = self.test_debug_endpoints(base_url or testable_endpoints[0]['url'])
        results['debug_endpoints'].extend(debug_vulns)
        
        # Authentication Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing authentication mechanisms...")
        auth_vulns = self.test_authentication(testable_endpoints)
        results['weak_authentication'].extend(auth_vulns)
        
        # Access Control Testing
        print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing access control...")
        access_vulns = self.test_access_control(testable_endpoints)
        results['broken_access_control'].extend(access_vulns)
        
        # TLS/HTTPS Testing
        if base_url:
            print(f"{Fore.BLUE}[INFO]{Style.RESET_ALL} Testing TLS/HTTPS configuration...")
            tls_vulns = self.test_tls_configuration(base_url)
            results['tls_issues'].extend(tls_vulns)
        
        return results

    def test_sql_injection(self, endpoints):
        """Test for SQL injection vulnerabilities with parallel processing"""
        vulnerabilities = []
        
        if self.fast_mode:
            # In fast mode, test only first 50 endpoints and use fewer payloads
            endpoints = endpoints[:50]
        
        def test_endpoint_sql(endpoint):
            endpoint_vulns = []
            url = endpoint['url']
            
            # Test GET parameters
            parsed_url = urlparse(url)
            if parsed_url.query:
                params = parse_qs(parsed_url.query)
                for param_name in params:
                    vulns = self._test_sql_parameter(url, param_name, 'GET')
                    endpoint_vulns.extend(vulns)
            
            # Test for forms (POST parameters)
            form_vulns = self._test_sql_forms(url)
            endpoint_vulns.extend(form_vulns)
            return endpoint_vulns
        
        # Use ThreadPoolExecutor for parallel processing
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_endpoint = {executor.submit(test_endpoint_sql, endpoint): endpoint for endpoint in endpoints}
            
            for future in as_completed(future_to_endpoint):
                try:
                    endpoint_vulns = future.result(timeout=self.timeout * 2)
                    vulnerabilities.extend(endpoint_vulns)
                except Exception as e:
                    self.log_verbose(f"Error testing SQL injection on endpoint: {e}")
        
        return vulnerabilities

    def _test_sql_parameter(self, url, param_name, method='GET'):
        """Test a specific parameter for SQL injection"""
        vulnerabilities = []
        
        for payload_info in self.sql_payloads.get_payloads(self.fast_mode):
            payload = payload_info['payload']
            payload_type = payload_info['type']
            
            try:
                if method == 'GET':
                    # Inject payload into parameter
                    parsed_url = urlparse(url)
                    params = parse_qs(parsed_url.query)
                    params[param_name] = [payload]
                    
                    new_query = urlencode(params, doseq=True)
                    test_url = urlunparse(parsed_url._replace(query=new_query))
                    
                    response = self.session.get(test_url, timeout=self.timeout)
                else:
                    data = {param_name: payload}
                    response = self.session.post(url, data=data, timeout=self.timeout)
                
                # Check for SQL error patterns
                if self._detect_sql_error(response.text):
                    vulnerabilities.append({
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        'type': payload_type,
                        'method': method,
                        'evidence': self._extract_sql_evidence(response.text),
                        'confidence': 'high'
                    })
                
                # Time-based detection
                elif payload_type == 'time_based':
                    if response.elapsed.total_seconds() > 5:
                        vulnerabilities.append({
                            'url': url,
                            'parameter': param_name,
                            'payload': payload,
                            'type': payload_type,
                            'method': method,
                            'evidence': f'Response delayed by {response.elapsed.total_seconds():.2f} seconds',
                            'confidence': 'medium'
                        })
                
                # Add small delay to avoid overwhelming the server
                time.sleep(0.1)
                
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities

    def _test_sql_forms(self, url):
        """Test forms for SQL injection"""
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action', url)
                method = form.get('method', 'GET').upper()
                
                # Get form inputs
                inputs = form.find_all(['input', 'textarea', 'select'])
                form_data = {}
                
                for input_field in inputs:
                    name = input_field.get('name')
                    if name and input_field.get('type') not in ['submit', 'button', 'hidden']:
                        form_data[name] = 'test'
                
                # Test each input field
                for field_name in form_data:
                    vulns = self._test_sql_parameter(urljoin(url, action), field_name, method)
                    vulnerabilities.extend(vulns)
        
        except Exception:
            pass
        
        return vulnerabilities

    def _detect_sql_error(self, response_text):
        """Detect SQL error patterns in response"""
        sql_errors = [
            r"SQL syntax.*MySQL",
            r"Warning.*mysql_.*",
            r"MySQLSyntaxErrorException",
            r"valid MySQL result",
            r"PostgreSQL.*ERROR",
            r"Warning.*pg_.*",
            r"valid PostgreSQL result",
            r"Oracle error",
            r"Oracle.*Driver",
            r"ORA-\d{5}",
            r"Microsoft.*ODBC.*SQL Server",
            r"SQLServer JDBC Driver",
            r"SqlException",
            r"SQLite/JDBCDriver",
            r"SQLite.Exception",
            r"System.Data.SQLite.SQLiteException",
            r"Warning.*sqlite_.*",
            r"[SQLITE_ERROR]"
        ]
        
        for pattern in sql_errors:
            if re.search(pattern, response_text, re.IGNORECASE):
                return True
        
        return False

    def _extract_sql_evidence(self, response_text):
        """Extract SQL error evidence from response"""
        sql_error_patterns = [
            r"(SQL syntax.*)",
            r"(Warning.*mysql_.*)",
            r"(PostgreSQL.*ERROR.*)",
            r"(Oracle error.*)",
            r"(Microsoft.*ODBC.*SQL Server.*)",
            r"(SQLite.*Exception.*)"
        ]
        
        for pattern in sql_error_patterns:
            match = re.search(pattern, response_text, re.IGNORECASE)
            if match:
                return match.group(1)[:200]  # Limit evidence length
        
        return "SQL error detected in response"

    def test_xss(self, endpoints):
        """Test for Cross-Site Scripting vulnerabilities with parallel processing"""
        vulnerabilities = []
        
        if self.fast_mode:
            # In fast mode, test only first 50 endpoints
            endpoints = endpoints[:50]
        
        def test_endpoint_xss(endpoint):
            endpoint_vulns = []
            url = endpoint['url']
            
            # Test GET parameters
            parsed_url = urlparse(url)
            if parsed_url.query:
                params = parse_qs(parsed_url.query)
                for param_name in params:
                    vulns = self._test_xss_parameter(url, param_name, 'GET')
                    endpoint_vulns.extend(vulns)
            
            # Test forms
            form_vulns = self._test_xss_forms(url)
            endpoint_vulns.extend(form_vulns)
            return endpoint_vulns
        
        # Use ThreadPoolExecutor for parallel processing
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            future_to_endpoint = {executor.submit(test_endpoint_xss, endpoint): endpoint for endpoint in endpoints}
            
            for future in as_completed(future_to_endpoint):
                try:
                    endpoint_vulns = future.result(timeout=self.timeout * 2)
                    vulnerabilities.extend(endpoint_vulns)
                except Exception as e:
                    self.log_verbose(f"Error testing XSS on endpoint: {e}")
        
        return vulnerabilities

    def _test_xss_parameter(self, url, param_name, method='GET'):
        """Test a specific parameter for XSS"""
        vulnerabilities = []
        
        for payload_info in self.xss_payloads.get_payloads(self.fast_mode):
            payload = payload_info['payload']
            payload_type = payload_info['type']
            
            try:
                if method == 'GET':
                    parsed_url = urlparse(url)
                    params = parse_qs(parsed_url.query)
                    params[param_name] = [payload]
                    
                    new_query = urlencode(params, doseq=True)
                    test_url = urlunparse(parsed_url._replace(query=new_query))
                    
                    response = self.session.get(test_url, timeout=self.timeout)
                else:
                    data = {param_name: payload}
                    response = self.session.post(url, data=data, timeout=self.timeout)
                
                # Check if payload is reflected unescaped
                if payload in response.text:
                    vulnerabilities.append({
                        'url': url,
                        'parameter': param_name,
                        'payload': payload,
                        'type': payload_type,
                        'method': method,
                        'evidence': f'Payload reflected in response',
                        'confidence': 'high' if '<script>' in payload else 'medium'
                    })
                
                time.sleep(0.1)
                
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities

    def _test_xss_forms(self, url):
        """Test forms for XSS"""
        vulnerabilities = []
        
        try:
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action', url)
                method = form.get('method', 'GET').upper()
                
                inputs = form.find_all(['input', 'textarea', 'select'])
                for input_field in inputs:
                    name = input_field.get('name')
                    if name and input_field.get('type') not in ['submit', 'button', 'hidden']:
                        vulns = self._test_xss_parameter(urljoin(url, action), name, method)
                        vulnerabilities.extend(vulns)
        
        except Exception:
            pass
        
        return vulnerabilities

    def test_csrf(self, endpoints):
        """Test for CSRF vulnerabilities"""
        vulnerabilities = []
        
        for endpoint in endpoints:
            url = endpoint['url']
            
            try:
                response = self.session.get(url, timeout=self.timeout)
                soup = BeautifulSoup(response.content, 'html.parser')
                
                forms = soup.find_all('form')
                for form in forms:
                    method = form.get('method', 'GET').upper()
                    
                    if method == 'POST':
                        # Check for CSRF tokens
                        csrf_token_found = False
                        inputs = form.find_all('input')
                        
                        for input_field in inputs:
                            name = input_field.get('name', '').lower()
                            if any(token in name for token in ['csrf', 'token', '_token', 'authenticity']):
                                csrf_token_found = True
                                break
                        
                        if not csrf_token_found:
                            vulnerabilities.append({
                                'url': url,
                                'form_action': form.get('action', ''),
                                'evidence': 'Form lacks CSRF protection',
                                'confidence': 'medium',
                                'type': 'missing_csrf_token'
                            })
            
            except Exception:
                continue
        
        return vulnerabilities

    def test_idor(self, endpoints):
        """Test for Insecure Direct Object Reference vulnerabilities"""
        vulnerabilities = []
        
        for endpoint in endpoints:
            url = endpoint['url']
            
            # Look for URLs with numeric IDs
            id_patterns = [
                r'/(\d+)/?$',
                r'[?&]id=(\d+)',
                r'[?&]user_id=(\d+)',
                r'[?&]account=(\d+)',
                r'/user/(\d+)',
                r'/account/(\d+)',
                r'/profile/(\d+)'
            ]
            
            for pattern in id_patterns:
                match = re.search(pattern, url)
                if match:
                    original_id = match.group(1)
                    
                    # Try different IDs
                    test_ids = [
                        str(int(original_id) + 1),
                        str(int(original_id) - 1),
                        str(int(original_id) + 100),
                        '1', '2', '0', '999'
                    ]
                    
                    for test_id in test_ids:
                        test_url = url.replace(original_id, test_id)
                        
                        try:
                            response = self.session.get(test_url, timeout=self.timeout)
                            
                            if response.status_code == 200 and len(response.content) > 100:
                                vulnerabilities.append({
                                    'url': url,
                                    'test_url': test_url,
                                    'original_id': original_id,
                                    'tested_id': test_id,
                                    'evidence': f'Accessing ID {test_id} returned valid response',
                                    'confidence': 'medium',
                                    'type': 'idor'
                                })
                        
                        except requests.exceptions.RequestException:
                            continue
        
        return vulnerabilities

    def test_file_disclosure(self, endpoints):
        """Test for file disclosure vulnerabilities"""
        vulnerabilities = []
        
        for endpoint in endpoints:
            url = endpoint['url']
            base_url = '/'.join(url.split('/')[:3])
            
            for payload_info in self.file_payloads.get_payloads():
                payload = payload_info['payload']
                file_type = payload_info['type']
                
                test_url = urljoin(base_url, payload)
                
                try:
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    if response.status_code == 200:
                        content = response.text.lower()
                        
                        # Check for file disclosure patterns
                        if self._detect_file_disclosure(content, file_type):
                            vulnerabilities.append({
                                'url': test_url,
                                'file_type': file_type,
                                'payload': payload,
                                'evidence': self._extract_file_evidence(content, file_type),
                                'confidence': 'high'
                            })
                
                except requests.exceptions.RequestException:
                    continue
        
        return vulnerabilities

    def _detect_file_disclosure(self, content, file_type):
        """Detect file disclosure based on content patterns"""
        patterns = {
            'passwd': [r'root:.*:0:0:', r'daemon:', r'bin:', r'sys:'],
            'env': [r'[A-Z_]+=.*', r'database.*password', r'secret.*key'],
            'config': [r'<configuration>', r'database.*connection', r'password.*='],
            'log': [r'\d{4}-\d{2}-\d{2}', r'error', r'warning', r'debug'],
            'backup': [r'backup', r'\.sql', r'database', r'export']
        }
        
        if file_type in patterns:
            for pattern in patterns[file_type]:
                if re.search(pattern, content, re.IGNORECASE):
                    return True
        
        return False

    def _extract_file_evidence(self, content, file_type):
        """Extract evidence from disclosed file content"""
        if file_type == 'passwd':
            match = re.search(r'(root:.*)', content)
            if match:
                return match.group(1)[:100]
        elif file_type == 'env':
            match = re.search(r'([A-Z_]+=.*)', content)
            if match:
                return match.group(1)[:100]
        
        return content[:100]

    def test_debug_endpoints(self, base_url):
        """Test for exposed debug endpoints"""
        vulnerabilities = []
        
        debug_endpoints = [
            '/debug', '/debug/', '/debug/pprof', '/debug/vars',
            '/console', '/console/', '/admin/console',
            '/.env', '/config', '/config.php', '/configuration.php',
            '/info.php', '/phpinfo.php', '/server-info', '/server-status',
            '/trace', '/trace/', '/actuator', '/actuator/health',
            '/actuator/env', '/actuator/configprops', '/health',
            '/metrics', '/status', '/stats', '/info'
        ]
        
        for endpoint in debug_endpoints:
            test_url = urljoin(base_url, endpoint)
            
            try:
                response = self.session.get(test_url, timeout=self.timeout)
                
                if response.status_code == 200:
                    content = response.text.lower()
                    
                    # Check for debug content patterns
                    debug_patterns = [
                        'php version', 'configuration', 'environment',
                        'debug', 'trace', 'stack trace', 'exception',
                        'database', 'password', 'secret', 'key'
                    ]
                    
                    for pattern in debug_patterns:
                        if pattern in content:
                            vulnerabilities.append({
                                'url': test_url,
                                'type': 'debug_endpoint',
                                'evidence': f'Debug endpoint exposed: {endpoint}',
                                'confidence': 'high'
                            })
                            break
            
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities

    def test_authentication(self, endpoints):
        """Test authentication mechanisms"""
        vulnerabilities = []
        
        # Look for login endpoints
        login_patterns = ['/login', '/signin', '/auth', '/admin']
        
        for endpoint in endpoints:
            url = endpoint['url']
            
            for pattern in login_patterns:
                if pattern in url.lower():
                    vulns = self._test_weak_credentials(url)
                    vulnerabilities.extend(vulns)
        
        return vulnerabilities

    def _test_weak_credentials(self, url):
        """Test for weak default credentials"""
        vulnerabilities = []
        
        # Common weak credentials
        weak_creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('admin', '123456'),
            ('administrator', 'administrator'),
            ('root', 'root'),
            ('test', 'test'),
            ('guest', 'guest'),
            ('demo', 'demo'),
            ('user', 'user'),
            ('user', 'password'),
            ('user', '123456'),
            ('user', 'letmein'),

        ]
        
        try:
            # Get login form
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            forms = soup.find_all('form')
            for form in forms:
                action = form.get('action', url)
                
                # Look for username/password fields
                username_field = None
                password_field = None
                
                inputs = form.find_all('input')
                for input_field in inputs:
                    input_type = input_field.get('type', '').lower()
                    name = input_field.get('name', '').lower()
                    
                    if input_type == 'text' or 'user' in name or 'email' in name:
                        username_field = input_field.get('name')
                    elif input_type == 'password':
                        password_field = input_field.get('name')
                
                if username_field and password_field:
                    for username, password in weak_creds:
                        data = {
                            username_field: username,
                            password_field: password
                        }
                        
                        try:
                            auth_response = self.session.post(
                                urljoin(url, action), 
                                data=data, 
                                timeout=self.timeout
                            )
                            
                            # Check for successful login indicators
                            if (auth_response.status_code in [200, 302] and
                                'dashboard' in auth_response.text.lower() or
                                'welcome' in auth_response.text.lower() or
                                'logout' in auth_response.text.lower()):
                                
                                vulnerabilities.append({
                                    'url': url,
                                    'username': username,
                                    'password': password,
                                    'type': 'weak_credentials',
                                    'evidence': f'Successful login with {username}:{password}',
                                    'confidence': 'high'
                                })
                        
                        except requests.exceptions.RequestException:
                            continue
                        
                        time.sleep(0.5)  # Rate limiting
        
        except Exception:
            pass
        
        return vulnerabilities

    def test_access_control(self, endpoints):
        """Test for broken access control"""
        vulnerabilities = []
        
        for endpoint in endpoints:
            url = endpoint['url']
            
            # Test without authentication
            try:
                response = self.session.get(url, timeout=self.timeout)
                
                # Check for admin/sensitive content accessible without auth
                content = response.text.lower()
                sensitive_patterns = [
                    'admin panel', 'dashboard', 'user management',
                    'delete user', 'edit user', 'configuration',
                    'database', 'settings', 'logs'
                ]
                
                for pattern in sensitive_patterns:
                    if pattern in content and response.status_code == 200:
                        vulnerabilities.append({
                            'url': url,
                            'type': 'broken_access_control',
                            'evidence': f'Sensitive content accessible: {pattern}',
                            'confidence': 'medium'
                        })
                        break
            
            except requests.exceptions.RequestException:
                continue
        
        return vulnerabilities

    def test_tls_configuration(self, base_url):
        """Test TLS/HTTPS configuration"""
        vulnerabilities = []
        
        # Check if HTTP version is accessible
        if base_url.startswith('https://'):
            http_url = base_url.replace('https://', 'http://')
            
            try:
                response = self.session.get(http_url, timeout=self.timeout)
                if response.status_code == 200:
                    vulnerabilities.append({
                        'url': http_url,
                        'type': 'http_accessible',
                        'evidence': 'Site accessible over HTTP (unencrypted)',
                        'confidence': 'high'
                    })
            except requests.exceptions.RequestException:
                pass
        
        # Check for security headers
        try:
            response = self.session.get(base_url, timeout=self.timeout)
            headers = response.headers
            
            # Check for missing security headers
            security_headers = {
                'Strict-Transport-Security': 'HSTS header missing',
                'X-Frame-Options': 'X-Frame-Options header missing',
                'X-Content-Type-Options': 'X-Content-Type-Options header missing',
                'Content-Security-Policy': 'CSP header missing'
            }
            
            for header, message in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'url': base_url,
                        'type': 'missing_security_header',
                        'evidence': message,
                        'confidence': 'medium'
                    })
        
        except requests.exceptions.RequestException:
            pass
        
        return vulnerabilities
